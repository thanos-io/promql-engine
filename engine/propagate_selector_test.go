// Copyright (c) The Thanos Community Authors.
// Licensed under the Apache License 2.0.

package engine_test

import (
	"context"
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/thanos-io/promql-engine/engine"
	"github.com/thanos-io/promql-engine/logicalplan"

	"github.com/cortexproject/promqlsmith"
	"github.com/efficientgo/core/testutil"
	"github.com/google/go-cmp/cmp"
	"github.com/prometheus/prometheus/model/labels"
	"github.com/prometheus/prometheus/promql"
	"github.com/prometheus/prometheus/promql/parser"
	"github.com/prometheus/prometheus/promql/promqltest"
)

func TestPropagateMatchers(t *testing.T) {
	t.Parallel()

	// Define test parameters
	seed := time.Now().UnixNano()
	rnd := rand.New(rand.NewSource(seed))
	testRuns := 10000

	// Create test data
	load := `load 30s
		http_requests_total{pod="nginx-1", job="app", env="prod", instance="1"} 1+1x40
		http_requests_total{pod="nginx-2", job="app", env="dev", instance="2"} 2+2x40
		http_requests_total{pod="nginx-3", job="api", env="prod", instance="3"} 3+3x40
		http_requests_total{pod="nginx-4", job="api", env="dev", instance="4"} 4+4x40
		http_requests_total2{pod="nginx-1", job="app", env="prod", instance="1"} 1+1x40
		http_requests_total2{pod="nginx-2", job="app", env="dev", instance="2"} 2+2x40
		http_requests_total2{pod="nginx-3", job="api", env="prod", instance="3"} 3+3x40
		http_requests_total2{pod="nginx-4", job="api", env="dev", instance="5"} 5+3x40
		http_requests_total3{pod="nginx-1", job="app", env="prod", cluster="us-west-2"} 1+1x40
		http_requests_total3{pod="nginx-2", job="app", env="dev", cluster="us-east-1"} 2+2x40
	`

	storage := promqltest.LoadedStorage(t, load)
	defer storage.Close()

	// Get series for PromQLSmith
	seriesSet, err := getSeries(context.Background(), storage, "http_requests_total")
	testutil.Ok(t, err)

	// Configure PromQLSmith
	psOpts := []promqlsmith.Option{
		promqlsmith.WithEnableOffset(false),
		promqlsmith.WithEnableAtModifier(false),
		promqlsmith.WithEnabledExprs([]promqlsmith.ExprType{promqlsmith.BinaryExpr, promqlsmith.VectorSelector}),
		promqlsmith.WithMaxDepth(3),
		promqlsmith.WithEnableVectorMatching(true),
	}
	ps := promqlsmith.New(rnd, seriesSet, psOpts...)

	// Engine options
	engineOpts := promql.EngineOpts{
		Timeout:              1 * time.Hour,
		MaxSamples:           1e10,
		EnableNegativeOffset: true,
		EnableAtModifier:     true,
	}

	normalEngine := engine.New(engine.Opts{
		EngineOpts:                  engineOpts,
		LogicalOptimizers:           logicalplan.NoOptimizers,
		DisableDuplicateLabelChecks: false,
	})

	optimizedEngine := engine.New(engine.Opts{
		EngineOpts: engineOpts,
		LogicalOptimizers: []logicalplan.Optimizer{
			logicalplan.SortMatchers{},
			logicalplan.MergeSelectsOptimizer{},
			logicalplan.PropagateMatchersOptimizer{},
		},
		DisableDuplicateLabelChecks: false,
	})

	ctx := context.Background()
	queryTime := time.Unix(600, 0)
	metricNameMapping := map[string]string{
		"http_requests_total":  "http_requests_total2",
		"http_requests_total2": "http_requests_total",
		"http_requests_total3": "http_requests_total",
	}

	t.Logf("Running %d fuzzy tests with seed %d", testRuns, seed)
	for i := range testRuns {
		var expr parser.Expr
		var query string

		// Generate a query that can be executed by the engine
		for {
			expr = ps.WalkInstantQuery()
			expr = logicalplan.UnwrapParens(expr)
			if _, ok := expr.(*parser.BinaryExpr); !ok {
				continue
			}

			// Binary expression generated by promqlsmith uses the same metric name.
			// Manually replace the metric name from one side
			replaceMetricNameIfEqual(expr, metricNameMapping)
			query = expr.Pretty(0)

			// Try to parse the query and see if it is valid.
			_, err := normalEngine.NewInstantQuery(ctx, storage, nil, query, queryTime)
			if err != nil {
				continue
			}
			break
		}

		t.Run(fmt.Sprintf("Query_%d", i), func(t *testing.T) {
			normalQuery, err := normalEngine.NewInstantQuery(ctx, storage, &engine.QueryOpts{}, query, queryTime)
			testutil.Ok(t, err)
			defer normalQuery.Close()
			normalResult := normalQuery.Exec(ctx)
			if normalResult.Err != nil {
				// Something wrong with the generated query so it even failed without projection pushdown, skipping.
				return
			}
			testutil.Ok(t, normalResult.Err, "query: %s", query)

			optimizedQuery, err := optimizedEngine.MakeInstantQuery(ctx, storage, &engine.QueryOpts{}, query, queryTime)
			testutil.Ok(t, err)

			defer optimizedQuery.Close()
			optimizedQueryResult := optimizedQuery.Exec(ctx)
			testutil.Ok(t, optimizedQueryResult.Err, "query: %s", query)

			if diff := cmp.Diff(normalResult, optimizedQueryResult, comparer); diff != "" {
				t.Errorf("Results differ for query %s: %s", query, diff)
			}
		})
	}
}

func replaceMetricNameIfEqual(node parser.Expr, metricNameMapping map[string]string) {
	parser.Inspect(node, func(node parser.Node, nodes []parser.Node) error {
		binOp, ok := (node).(*parser.BinaryExpr)
		if !ok {
			return nil
		}
		LHS, ok := binOp.LHS.(*parser.VectorSelector)
		if !ok {
			return nil
		}
		RHS, ok := binOp.LHS.(*parser.VectorSelector)
		if !ok {
			return nil
		}
		lhsName := extractMetricName(LHS.LabelMatchers)
		rhsName := extractMetricName(RHS.LabelMatchers)
		if lhsName != rhsName {
			return nil
		}
		mappedMetricName, ok := metricNameMapping[lhsName]
		if !ok {
			return nil
		}
		for _, matcher := range RHS.LabelMatchers {
			if matcher.Name == labels.MetricName {
				matcher.Value = mappedMetricName
			}
		}
		return nil
	})
}

func extractMetricName(matchers []*labels.Matcher) string {
	for _, matcher := range matchers {
		if matcher.Name == labels.MetricName {
			return matcher.Value
		}
	}
	return ""
}
